<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · BellDiagonalQudits.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="BellDiagonalQudits.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">BellDiagonalQudits.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Package-installation"><span>Package installation</span></a></li><li><a class="tocitem" href="#State-generation"><span>State generation</span></a></li><li><a class="tocitem" href="#Analysis-prerequisites"><span>Analysis prerequisites</span></a></li><li><a class="tocitem" href="#Entanglement-classification"><span>Entanglement classification</span></a></li><li><a class="tocitem" href="#Entanglement-distillation"><span>Entanglement distillation</span></a></li></ul></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kungfugo/BellDiagonalQudits.jl/blob/main/docs/src/manual.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><p>This manual shows how to use the package by using it to sample a set of uniformly distributed Bell diagonal states and to analyse their entanglement properties. Here, we apply criteria for separability and entanglement to determine the entanglement class of generated bipartite qutrits, i.e. <code>d=3</code>. In this system, bound entangled states, i.e. entangled states with positive partial transposition (PPT) that cannot be used for entanglement distillation, exist. The entanglement classes are labeled &quot;SEP&quot; for separability, &quot;BOUND&quot; for bound entanglement, &quot;FREE&quot; for entanglement with negative partial transposition (i.e. distillable) and &quot;PPT_UNKNOWN&quot; for PPT states that could not be classified as entangled or separable.</p><h2 id="Package-installation"><a class="docs-heading-anchor" href="#Package-installation">Package installation</a><a id="Package-installation-1"></a><a class="docs-heading-anchor-permalink" href="#Package-installation" title="Permalink"></a></h2><p>BellDiagonalQudits can be installed using the Julia package manager. From the Julia REPL, type <code>]</code> to enter the Pkg REPL mode and run</p><pre><code class="nohighlight hljs">pkg&gt; add BellDiagonalQudits</code></pre><p>The package can be loaded via</p><pre><code class="language-julia hljs">julia&gt; using BellDiagonalQudits</code></pre><h2 id="State-generation"><a class="docs-heading-anchor" href="#State-generation">State generation</a><a id="State-generation-1"></a><a class="docs-heading-anchor-permalink" href="#State-generation" title="Permalink"></a></h2><p>Create a basis of maximally entangled bipartite Bell states in <code>d^2</code> dimensions. Each Bell basis state is created by applying a certain Weyl transformation to the maximally entangled state. Sample Bell diagonal random mixed states of those Bell states, represented by their <code>d^2</code> coordinates (mixing probabilities) in the Bell basis.</p><p><br/><strong>Bell basis generation</strong></p><p>Create a Bell basis <code>myBasis</code> by applying each of the <code>d^2</code> Weyl transformations <code>W_{k,l} \\otimes \\mathbb{1}_d</code> to the maximally entangled state.<code>myBasis.basis</code> contains the enumerated Bell states in computational basis together with the indices of the corresponding Weyl transformation. <code>myBasisDict</code> contains the dictionaries to relate the enumerated <code>d^2</code> Bell basis states to the double indices <code>(k,l)</code> of the corresponding Weyl transformation.</p><pre><code class="language-julia hljs">d = 3
myBasis = create_standard_indexbasis(d,10)
myBasisDict = create_dictionary_from_basis(myBasis)</code></pre><p><br/><strong>State sampling</strong></p><p>Create uniformly distributed random representations of quantum states by specifying the coordinates of the state in the created Bell basis. The coordinates represent the mixing probabilities of the Bell basis states. Here, we create only states with Bell coordinates within the &quot;enclosure polytope&quot;, which is defined by the limitation of all coordinates (mixing probabilities) to be smaller than or equal to <code>1/d</code>. This subset is known to contain all (but not only) states with positive partial transposition (PPT), which can be separable or bound entangled.</p><pre><code class="language-julia hljs">myCoordStates = uniform_bell_sampler(100, d, :enclosurePolytope)</code></pre><p>Create <code>DensityState</code>s including the density matrix of each state in the computational basis, created by mixing the Bell states of <code>myBasis</code> according to the <code>coords</code> of <code>myCoordStates</code>.</p><pre><code class="language-julia hljs">myDensityStates = map(x-&gt;create_densitystate(x, myBasis), myCoordStates)</code></pre><h2 id="Analysis-prerequisites"><a class="docs-heading-anchor" href="#Analysis-prerequisites">Analysis prerequisites</a><a id="Analysis-prerequisites-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-prerequisites" title="Permalink"></a></h2><p>Now create the analysis objects required for the entanglement classification using several criteria for entanglement or separability.</p><p><br/><strong>Separable kernel polytope</strong></p><p>The kernel polytope is known to contain only Bell coordinates that represent separable states. It is defined as the convex hull of vertices related to special separable states called &quot;subgroup states&quot;. The related <code>kernel check</code> tests if the Bell coordinates of a given unclassified state are contained in this convex hull and thus indicates separability.</p><pre><code class="language-julia hljs">mySepKernel = create_kernel_polytope(d, myBasis)
</code></pre><p>If additional separable states <code>newSepDensityStates</code> are known, the kernel polytope can be exteded to a larger convex hull in order to improve the kernel check for separability. For a (trivial) example, consider the separable, maximally mixed state having all Bell states mixed equally with probability <code>1/d^2</code>. First,specify the coordinates in the Bell basis and set the <code>eClass</code> of the corresponding <code>CoordState</code> to &quot;SEP&quot;. Then, calculate the density matrix and create the <code>DensityState</code>. Finally, extend the kernel polytope <code>mySepKernel</code> by the array containing this separable state.</p><pre><code class="language-julia hljs">maxMixedCoordState = CoordState(1/d^2*ones(d^2), &quot;SEP&quot;)
maxMixedDensityState = create_densitystate(maxMixedCoordState, myBasis)
newSepDensityStates = [maxMixedDensityState]
myExtendedKernel = extend_vpolytope_by_densitystates(tovrep(mySepKernel), newSepDensityStates, 10)
</code></pre><p><br/><strong>Weyl operator basis</strong></p><p>Use the Weyl operators to construct a basis of the space of <code>(d^2,d^2)</code> matrices. This object is used for the <code>spinrep check</code> indicating separability according to the representation of the density matrix of a given state in this basis.</p><pre><code class="language-julia hljs">myWeylOperatorBasis = create_bipartite_weyloperator_basis(d)</code></pre><p><br/><strong>Mutually unbiased bases (MUBs)</strong></p><p>Create the a set of mutually unbiased bases (MUBs) constructed with the Weyl operators and represented in the computational basis.</p><pre><code class="language-julia hljs">myMub = create_standard_mub(d)</code></pre><p><br/><strong>Symmetries</strong></p><p>Generate entanglement class conserving symmetries represented as permutations of state coordinates in the Bell basis. Given a classified state, the orbit, i.e. the set of states that are generated by applying all symmetries to the classified state, is known to be of the same entanglement class. The symmetries can be used to improve the entanglement classification.</p><pre><code class="language-julia hljs">mySyms = generate_symmetries(myBasis, d)</code></pre><p><br/><strong>Entanglement witnesses</strong></p><p>Generate <code>n</code> numerical entanglement witnesses by numerical optimization over the set of separable states. Here, the entanglement witnesses are represented by their coordinates in the Bell basis, an upper, and a lower bound. For all separable states, the inner product of the state and witness coordinates obeys these bounds. A violation of the inner product of an unknown state and the witness thus indicates entanglement. Use <code>iterations</code> runs to improve the determined upper and lower bounds. Other optimization methods than the default <code>NelderMead</code> can be used.</p><pre><code class="language-julia hljs">n = 2
myOptimizedEWs = create_random_bounded_ews(
    d,
    myBasis,
    n,
    true,
    20
    )</code></pre><pre><code class="language-julia hljs">myOptimizedCoodEWs = map(x-&gt;get_bounded_coordew(x), myOptimizedEWs)</code></pre><h2 id="Entanglement-classification"><a class="docs-heading-anchor" href="#Entanglement-classification">Entanglement classification</a><a id="Entanglement-classification-1"></a><a class="docs-heading-anchor-permalink" href="#Entanglement-classification" title="Permalink"></a></h2><p><strong>Analysis specification</strong></p><p>Specify, which entanglement checks to use. See properties of type <code>AnalysisSpecification</code>. In this case we check separability with the kernel and spinrep check and test for entanglement using the ppt, realignment, concurrence<em>qp and numeric</em>ew check.</p><pre><code class="language-julia hljs">myAnaSpec = AnalysisSpecification(
   true,
   true,
   true,
   true,
   true,
   false,
   true,
   false
)</code></pre><p><br/><strong>Apply analysis to all generated states</strong></p><p>If <code>useSymmetries == false</code> in the analysis specification <code>myAnaSpec</code> use <code>analyse_coordstate</code>, else use <code>sym_analyse_coordstate</code> to leverage the symmetries <code>mySyms</code> for improved classification.</p><pre><code class="language-julia hljs">f(x) = analyse_coordstate(
    d,
    x,
    myAnaSpec,
    myBasis,
    mySepKernel,
    myWeylOperatorBasis,
    myBasisDict,
    missing,
    myOptimizedCoodEWs
)

    myAnalysedCoordStates = map(x-&gt;f(x), myCoordStates)</code></pre><p>Finally use analysis results to set <code>CoordState.eClass</code> to assign the entanglement class to the states.</p><pre><code class="language-julia hljs">classify_analyzed_states!(myAnalysedCoordStates)</code></pre><p>Identify e.g. bound entangled states as</p><pre><code class="language-julia hljs">myBoundStates = filter(x-&gt;x.coordState.eClass == &quot;BOUND&quot;, myAnalysedCoordStates)</code></pre><h2 id="Entanglement-distillation"><a class="docs-heading-anchor" href="#Entanglement-distillation">Entanglement distillation</a><a id="Entanglement-distillation-1"></a><a class="docs-heading-anchor-permalink" href="#Entanglement-distillation" title="Permalink"></a></h2><p>Create and distill a Bell-diagonal state with the FIMAX protocol. First, create a test state.</p><pre><code class="language-julia hljs">d=3
testBDS = create_densitystate(CoordState([0.5, 0.5 / 8, 0.5 / 8, 0.5 / 8, 0.5 / 8, 0.5 / 8, 0.5 / 8, 0.5 / 8, 0.5 / 8], &quot;UNKNOWN&quot;), myBasis).densityMatrix
</code></pre><p>To execute one iteration of the FIMAX routine, run:</p><pre><code class="language-julia hljs">FIMAX_routine_results = FIMAX_routine(testBDS, 2, d, myBasis)</code></pre><p>To iterate this procedure until a target fidelity of 0.99 with the maximally entangled state is achieved, execute:</p><pre><code class="language-julia hljs">FIMAX_protocol_results = iterative_FIMAX_protocol(testBDS, 0.99, 2, d, testStandardBasis3, 100)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../library/">Library »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 6 August 2024 11:38">Tuesday 6 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
